import trino
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm


def get_trino_connection(host, username, password):
    return trino.dbapi.connect(
        host=host,
        port=443,
        user=username,
        auth=trino.auth.BasicAuthentication(username, password),
        http_scheme="https",
        verify=False
    )


def get_base_tables(cursor, catalog, schema):
    query = f"""
        SELECT table_name
        FROM {catalog}.information_schema.tables
        WHERE table_schema = '{schema}' AND table_type = 'BASE TABLE'
    """
    cursor.execute(query)
    return [row[0] for row in cursor.fetchall()]


def sync_partition(cursor, catalog, schema, table, dry_run):
    query = (
        f"CALL {catalog}.system.sync_partition_metadata("
        f"'{schema}', '{table}', 'FULL', false)"
    )
    if dry_run:
        print(f"[Dry Run] Would run: {query}")
    else:
        cursor.execute(query)
        return f"[INFO] Synced: {schema}.{table}"


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--trino_host", required=True)
    parser.add_argument("--username", required=True)
    parser.add_argument("--password", required=True)
    parser.add_argument("--catalog", required=True)
    parser.add_argument("--schema", required=True)
    parser.add_argument("--dry_run", type=bool, default=True)
    args = parser.parse_args()

    conn = get_trino_connection(args.trino_host, args.username, args.password)
    cursor = conn.cursor()

    tables = get_base_tables(cursor, args.catalog, args.schema)

    if not tables:
        print(f"[INFO] No base tables found in {args.catalog}.{args.schema}. Exiting.")
        return

    if args.dry_run:
        for table in tables:
            sync_partition(cursor, args.catalog, args.schema, table, dry_run=True)
    else:
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = {
                executor.submit(sync_partition, cursor, args.catalog, args.schema, table, dry_run=False): table
                for table in tables
            }
            for future in tqdm(as_completed(futures), total=len(futures), desc="Syncing Partitions"):
                try:
                    result = future.result()
                    if result:
                        print(result)
                except Exception as e:
                    print(f"[ERROR] Failed syncing {futures[future]}: {e}")


if __name__ == "__main__":
    main()
